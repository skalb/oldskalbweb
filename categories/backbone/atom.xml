<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Backbone | skalb.com]]></title>
  <link href="http://www.skalb.com/categories/backbone/atom.xml" rel="self"/>
  <link href="http://www.skalb.com/"/>
  <updated>2013-07-07T15:23:27-07:00</updated>
  <id>http://www.skalb.com/</id>
  <author>
    <name><![CDATA[Sameer Kalburgi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Testing Backbone Routers in Meteor with Mocha]]></title>
    <link href="http://www.skalb.com/2012/08/20/testing-backbone-routers-in-meteor-with-mocha/"/>
    <updated>2012-08-20T00:00:00-07:00</updated>
    <id>http://www.skalb.com/2012/08/20/testing-backbone-routers-in-meteor-with-mocha</id>
    <content type="html"><![CDATA[<p>One of the downsides of Meteor and perhaps strongest complaint is that it doesn&rsquo;t play nicely with existing NodeJS modules. You&rsquo;re forced to use the available SmartPackages (or build one). This is a problem since the Mocha environment runs without the browser and doesn&rsquo;t have access to the libraries included by the SmartPackage.</p>

<!--more-->


<p><em>Here&rsquo;s a previous <a href="http://www.skalb.com/2012/08/19/testing-with-meteor-coffeescript-and-mocha/">post</a> describing how to setup everything</em></p>

<p>Creating the project:</p>

<p><code>bash
meteor create mocha-router
meteor add backbone
meteor add coffeescript
cd mocha-router
mkdir client
mkdir server
mkdir tests
cd tests
mkdir lib
</code></p>

<p>When I first installed the modules, I installed them in my project root, but this caused Meteor to try to load them in the both the client/server environment which crashed the Meteor server. Luckily, Meteor will ignore anything in the tests folder so we can install the necessary modules there.</p>

<p><code>bash
npm install should
npm install backbone
mocha *.coffee --compilers coffee:coffee-script
</code></p>

<p>My goal was to create a very basic Backbone router test. Normally, I&rsquo;d define the router like so:</p>

<p>``` coffeescript
SampleRouter = @Backbone.Router.extend(
  routes:</p>

<pre><code>"": "index"
</code></pre>

<p>  index: &ndash;>
)
new SampleRouter
```</p>

<p>This won&rsquo;t work when running the Mocha tests because it assumes the Meteor framework is present to load Backbone. I solved this by creating a factory for the router and injecting the Backbone module.</p>

<p>Note, I need to put this module in tests/lib so Meteor will make sure to load it first</p>

<p>lib/sample_router_factory.coffee:
``` coffeescript
root = exports ? this</p>

<p>class SampleRouterFactory
  constructor: (@Backbone) &ndash;></p>

<p>  getRouter: () &ndash;></p>

<pre><code>SampleRouter = @Backbone.Router.extend(
  routes:
    "": "index"

  index: -&gt;
    Session.set "test", "test"
)
new SampleRouter
</code></pre>

<p>root.SampleRouterFactory = SampleRouterFactory
```</p>

<p>Exports is a global object accessible in the nodeJS environment that Mocha runs in. See this <a href="http://visionmedia.github.com/masteringnode/book.html">ebook</a> for more details.</p>

<p>This module will now create a class that will return a new instance of the SampleRouter.</p>

<p>Now, let&rsquo;s look at the test case:</p>

<p>tests/sample_router_factory_test.coffee
``` coffeescript
should = require(&lsquo;should&rsquo;)
Backbone = require(&lsquo;backbone&rsquo;)
SampleRouterFactory = require(&lsquo;../client/lib/sample_router_factory&rsquo;).SampleRouterFactory</p>

<p>describe &ldquo;SampleRouter&rdquo;, &ndash;>
  factory = new SampleRouterFactory(Backbone)
  router = factory.getRouter(Backbone)
  it &ldquo;should have an index router&rdquo;, &ndash;></p>

<pre><code>router.routes[''].should.equal('index')
</code></pre>

<p>```</p>

<p>Lastly, in the actual Meteor app I create the app a similar way:</p>

<p>mocha-router.coffee
<code>coffeescript
Meteor.startup -&gt;
  factory = new SampleRouterFactory(Backbone)
  router = factory.getRouter(Backbone)
</code></p>

<p>Again, there&rsquo;s no need to require either Backbone (loaded as a SmartPackage) or the actual SampleRouterFactory because Meteor treats all of your CoffeeScript files as a single file and consequently scope.</p>

<p><a href="https://github.com/skalb/meteor-examples/tree/master/mocha-router">Source code here.</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Handling permalinks in Backbone.js with Routers]]></title>
    <link href="http://www.skalb.com/2012/04/30/handling-permalinks-in-backbone-js-with-routers/"/>
    <updated>2012-04-30T00:00:00-07:00</updated>
    <id>http://www.skalb.com/2012/04/30/handling-permalinks-in-backbone-js-with-routers</id>
    <content type="html"><![CDATA[<p>This post is part of a series:</p>

<ul>
    <li>[First post](http://www.skalb.com/2012/04/23/how-to-easily-handle-model-relationships-in-rails-and-backbone-js/)</li>
    <li>[Second post](http://www.skalb.com/2012/04/26/extending-and-refactoring-views-in-backbone/)</li>
</ul>


<p>One of the missing features in my prototype was handling of permalinks. To make things easy, I originally removed all the routes and added click handlers instead. In retrospect that was a mistake. Instead of having the app logic tangled up with click handlers, it would have been much more straightforward to define routes and use links.</p>

<p>Here’s the <a href="https://github.com/skalb/trackbone%22>source&lt;/a>%C2%A0and%C2%A0&lt;a%20href=%22http://young-flower-9677.herokuapp.com/">demo</a>.</p>

<!--more-->


<p>In this post, I’m going to explain the  Backbone router step by step. First, I need to actually define what routes I want:</p>

<p>I need:</p>

<ul>
    <li>Home page -> Load list of projects</li>
    <li>Selected project -> Load list of projects and features</li>
    <li>Selected feature -> Load list of projects, features, and bugs</li>
</ul>


<p><code>coffeescript
routes:
  ".*"  : "showProjects"
  "projects/:project_id" : "showProjects"
  "projects/:project_id/features/:feature_id/*" : "showProjects"
</code></p>

<p>Notice that all my routes point to the same function. The only difference is that the project_id and feature_id variables will be undefined. JavaScript won’t complain if your function call doesn’t match the function signature. It will just set them undefined.</p>

<p>Now let’s look at showProjects.</p>

<p>``` coffeescript
showProjects: (project_id, feature_id, bug_id) &ndash;>
  @renderViews(@projects, project_id, &ldquo;Projects&rdquo;)</p>

<p>  if project_id
    @loadChildren(@projects, project_id, [feature_id, bug_id], &ldquo;loadFeatures&rdquo;)
```</p>

<p>My original goal was to create a helper method that would support an abitrary length chain of loading children. That is, loadChildren will call loadFeatures which will then call loadChildren again etc. The final implementation isn’t quite that generic since it requires me to construct the individual item_ids at the start.</p>

<p>As I was finishing this prototype , I managed to remove all duplicate code by creating some helper methods.</p>

<p>`&ldquo; coffeescript
clearType: (model) &ndash;>
  $(&ldquo;#list-#{model}&rdquo;).html(&rdquo;)
  $(&ldquo;#new-#{model}&rdquo;).html(&lsquo;&rsquo;)</p>

<p>renderView: (selector, view) &ndash;>
  $(selector).html(view.render().el)</p>

<p>renderViews: (items, item_id, type) &ndash;>
  indexView = new Trackbone.Views.IndexView(items: items, id: item_id, type: type)
  @renderView(&ldquo;#list-#{type.toLowerCase()}&rdquo;, indexView)</p>

<p>  newView = new Trackbone.Views.NewView(collection: items, type: type)
  @renderView(&ldquo;#new-#{type.toLowerCase()}&rdquo;, newView)
```</p>

<p>And now let’s look at loadChildren:</p>

<p><code>coffeescript
loadChildren: (items, item_id, child_ids, callback) -&gt;
  item = items.get(item_id)
  item.loadChildren()
  item.children.fetch(
    success: =&gt;
      @[callback](item.children, child_ids.shift(), child_ids)
  )
  item.children.fetch()
</code></p>

<p>Okay, why am I indexing into the object with a string instead of just passing the function in directly. Well, because the fat arrow wasn’t working as expected. Either I was doing something wrong or there&rsquo;s a bug in the coffee-rails interpreter because js2coffee gave me a different result.</p>

<p>The full router:</p>

<p>``` coffeescript
class Trackbone.Routers.ProjectsRouter extends Backbone.Router
  initialize: (options) &ndash;>
    @projects = new Trackbone.Collections.ProjectsCollection()
    @projects.reset options.projects</p>

<p>  routes:
    ".<em>&ldquo;  : "showProjects&rdquo;
    "projects/:project_id" : &ldquo;showProjects&rdquo;
    "projects/:project_id/features/:feature_id/</em>&ldquo; : "showProjects&rdquo;</p>

<p>  clearType: (model) &ndash;>
    $(&ldquo;#list-#{model}&rdquo;).html(&lsquo;&rsquo;)
    $(&ldquo;#new-#{model}&rdquo;).html(&lsquo;&rsquo;)</p>

<p>  loadChildren: (items, item_id, child_ids, callback) &ndash;>
    item = items.get(item_id)
    item.loadChildren()
    item.children.fetch(
      success: =>
        @<a href="item.children,%20child_ids.shift(">callback</a>, child_ids)
    )
    item.children.fetch()</p>

<p>  renderView: (selector, view) &ndash;>
    $(selector).html(view.render().el)</p>

<p>  renderViews: (items, item_id, type) &ndash;>
    indexView = new Trackbone.Views.IndexView(items: items, id: item_id, type: type)
    @renderView(&ldquo;#list-#{type.toLowerCase()}&rdquo;, indexView)</p>

<p>    newView = new Trackbone.Views.NewView(collection: items, type: type)
    @renderView(&ldquo;#new-#{type.toLowerCase()}&rdquo;, newView)</p>

<p>  showProjects: (project_id, feature_id, bug_id) &ndash;>
    @renderViews(@projects, project_id, &ldquo;Projects&rdquo;)</p>

<p>    if project_id
      @loadChildren(@projects, project_id, [feature_id, bug_id], &ldquo;loadFeatures&rdquo;)</p>

<p>  loadFeatures: (features, feature_id, child_ids) &ndash;>
    @renderViews(features, feature_id, &ldquo;Features&rdquo;)</p>

<p>    if feature_id
      @loadChildren(features, feature_id, child_ids, &ldquo;loadBugs&rdquo;)
    else
      @clearType(&ldquo;bugs&rdquo;)</p>

<p>  loadBugs: (bugs, bug_id, child_ids) &ndash;>
    @renderViews(bugs, bug_id, &ldquo;Bugs&rdquo;)
```</p>

<p>I also needed to tweak my item view to include the correct url for the select link.</p>

<p>``` coffeescript
Trackbone.Views.Projects ||= {}</p>

<p>class Trackbone.Views.ItemView extends Backbone.View
  template: JST[&ldquo;backbone/templates/item&rdquo;]</p>

<p>  events:
    "click .destroy" : &ldquo;destroy&rdquo;</p>

<p>  tagName: &ldquo;tr&rdquo;
  className: &ldquo;item&rdquo;</p>

<p>  destroy: () &ndash;>
    @model.destroy()
    this.remove()</p>

<p>    return false</p>

<p>  render: &ndash;>
    name = @model.get(&ldquo;name&rdquo;)
    id = @model.get(&ldquo;id&rdquo;)
    url = &ldquo;#{@model.collection.url()}/#{id}&rdquo;
    $(@el).html(@template(name: name, id: id, url: url))
    if (@options.selected)
      window.toggleSelected(@el)
    return this</p>

<p>```</p>

<p>Again, here’s the <a href="https://github.com/skalb/trackbone%22>source&lt;/a>%C2%A0and%C2%A0&lt;a%20href=%22http://young-flower-9677.herokuapp.com/">demo</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Extending and refactoring views in Backbone.js]]></title>
    <link href="http://www.skalb.com/2012/04/26/extending-and-refactoring-views-in-backbone/"/>
    <updated>2012-04-26T00:00:00-07:00</updated>
    <id>http://www.skalb.com/2012/04/26/extending-and-refactoring-views-in-backbone</id>
    <content type="html"><![CDATA[<p>In a <a href="http://www.skalb.com/2012/04/23/how-to-easily-handle-model-relationships-in-rails-and-backbone-js/">previous post</a>, I built an example single page app using Backbone. One thing that bothered me was how similar the views are, yet didn&rsquo;t share any code. I think part of this was that I originally scaffolded the entire app and worked backwards.</p>

<!--more-->


<p>For example, here&rsquo;s Project vs Feature Index Templates:
``` html</p>

<h1>Listing projects</h1>




<table id="projects-table">
  <tr>
    <th>Name</th>
    <th></th>
  </tr>
</table>




<br/>


<p>```</p>

<p>vs.</p>

<p>``` html</p>

<h1>Listing features</h1>




<table id="features-table">
  <tr>
    <th>Name</th>
    <th></th>
  </tr>
</table>




<br/>


<p>```</p>

<p>This is easily refactored to:
``` html</p>

<h1>Listing <%= type %></h1>




<table id="items-table">
  <tr>
    <th>Name</th>
    <th></th>
  </tr>
</table>




<br/>


<p><code>
Similarly, the New View changed from:
</code> html</p>

<h1>New project</h1>


<p><form id="new-project" name="project">
  <div class="field"></p>

<pre><code>&lt;label for="name"&gt; name:&lt;/label&gt;
&lt;input type="text" name="name" id="name" value="&lt;%= name %&gt;" &gt;
</code></pre>

<p>  </div></p>

<p>  <div class="actions"></p>

<pre><code>&lt;input type="submit" value="Create Project" /&gt;
</code></pre>

<p>  </div></p>

<p></form>
<code>
to
</code> html</p>

<h1>New <%= type %></h1>


<p><form id="new-item">
  <div class="field"></p>

<pre><code>&lt;label for="name"&gt; name:&lt;/label&gt;
&lt;input type="text" name="name" id="name" value="&lt;%= name %&gt;" &gt;
</code></pre>

<p>  </div></p>

<p>  <div class="actions"></p>

<pre><code>&lt;input type="submit" value="Create &lt;%= type %&gt;" /&gt;
</code></pre>

<p>  </div></p>

<p></form>
```</p>

<p>Great, that was easy and now I just reduced my total Templates. To share functionality between the Views I needed to create a base View class:</p>

<p>``` coffeescript
Trackbone.Views ||= {}</p>

<p>class Trackbone.Views.IndexView extends Backbone.View
  template: JST[&ldquo;backbone/templates/index&rdquo;]</p>

<p>  initialize: () &ndash;></p>

<pre><code>@options.items.bind('reset', @addAll)
@options.items.bind('sync', @addAll)
</code></pre>

<p>  addAll: () =></p>

<pre><code># This shouldn't be needed, but for some reason
# lists are rendered twice
@$("tbody").html('')

@options.items.each(@addOne)
</code></pre>

<p>  addOne: (item) =></p>

<pre><code>item.collection = @options.items
@$("tbody").append(@getView({model: item}).render().el)
</code></pre>

<p>  render: =></p>

<pre><code>$(@el).html(@template(type: @options.type))
@addAll()

return this
</code></pre>

<p>```</p>

<p>First thing to note is that this View has an initialize method. But that method will never be called automatically because we&rsquo;re going to extend this View into a new class and create an instance of the subclass instead. Also note that we&rsquo;re calling a function getView() that isn&rsquo;t defined in this class.</p>

<p>``` coffeescript</p>

<h1>= require ../index_view</h1>

<p>Trackbone.Views.Projects ||= {}</p>

<p>class Trackbone.Views.Projects.IndexView extends Trackbone.Views.IndexView
  initialize: () &ndash;></p>

<pre><code>super
@options.type = "Projects"
</code></pre>

<p>  getView: (options) =></p>

<pre><code>new Trackbone.Views.Projects.ProjectView(options)
</code></pre>

<p>```</p>

<p>We can call the into the parent class by using super in this view&rsquo;s initialize. This is just a <a href="http://coffeescript.org/#classes">CoffeeScript shortcut</a> to apply the same arguments to the parent&rsquo;s constructor. I&rsquo;ve also explicitly required the parent View class since Rails does not guarantee which order JavaScript files will be loaded in the browser. The getView function here creates the correct ItemView based off the Project model.</p>

<p>The New item View shown below is generic enough that it did not need to be extended for each model.</p>

<p>``` coffeescript
Trackbone.Views.Projects ||= {}</p>

<p>class Trackbone.Views.NewView extends Backbone.View
  template: JST[&ldquo;backbone/templates/new&rdquo;]</p>

<p>  events:</p>

<pre><code>"submit #new-item": "save"
</code></pre>

<p>  save: (e) &ndash;></p>

<pre><code>e.preventDefault()
e.stopPropagation()

name = @.$("#new-item #name").val()
if name
  $("#new-item #name").val('')
  @collection.create(name: name)
</code></pre>

<p>  render: &ndash;></p>

<pre><code>$(@el).html(@template(type: @options.type))

return this
</code></pre>

<p>```</p>

<p>The Item View is a bit trickier because it contained the select handling for when an item was clicked. To be able to reuse the handling, I had to make the load methods consistently named loadChildren as shown below.</p>

<p>``` coffeescript
class Trackbone.Models.Project extends Backbone.Model
  paramRoot: &lsquo;project&rsquo;</p>

<p>  defaults:</p>

<pre><code>name: null
</code></pre>

<p>  loadChildren: &ndash;></p>

<pre><code>@children = new Trackbone.Collections.FeaturesCollection([], {project_url: @url()});
</code></pre>

<p>class Trackbone.Collections.ProjectsCollection extends Backbone.Collection
  model: Trackbone.Models.Project
  url: &lsquo;/projects&rsquo;
```</p>

<p>One thing to point out in the Item View base class is that I believe I could have used the <a href="http://coffeescript.org/#fat_arrow">fat arrow</a> to retain the correct context.</p>

<p>``` coffeescript
Trackbone.Views.Projects ||= {}</p>

<p>class Trackbone.Views.ItemView extends Backbone.View
  template: JST[&ldquo;backbone/templates/item&rdquo;]</p>

<p>  events:</p>

<pre><code>"click .select" : "select"
"click .destroy" : "destroy"
</code></pre>

<p>  tagName: &ldquo;tr&rdquo;
  className: &ldquo;item&rdquo;</p>

<p>  select: () &ndash;></p>

<pre><code>if @model.loadChildren
  window.toggleSelected(@el)
  @model.loadChildren()
  do (@model, @renderChildren) -&gt;
    @model.children.fetch(
      success: @renderChildren(@model.children)
    )
    @model.children.fetch()
</code></pre>

<p>  destroy: () &ndash;></p>

<pre><code>@model.destroy()
this.remove()

return false
</code></pre>

<p>  render: &ndash;></p>

<pre><code>$(@el).html(@template(@model.toJSON() ))
return this
</code></pre>

<p>```</p>

<p>Now the actual Project view only had to define how to render it&rsquo;s children.</p>

<p>``` coffeescript</p>

<h1>= require ../item_view</h1>

<p>Trackbone.Views.Projects ||= {}</p>

<p>class Trackbone.Views.Projects.ProjectView extends Trackbone.Views.ItemView
  template: JST[&ldquo;backbone/templates/item&rdquo;]</p>

<p>  renderChildren: (children) &ndash;></p>

<pre><code>featuresView = new Trackbone.Views.Features.IndexView(items: children)
$("#list-features").html(featuresView.render().el)

# We should probably only render this once instead of each load
newFeaturesView = new Trackbone.Views.NewView(collection: children, type: "Features")
$("#new-features").html(newFeaturesView.render().el)

$("#list-bugs").html('')
$("#new-bugs").html('')
</code></pre>

<p>```</p>

<p>Again, here&rsquo;s the <a href="http://young-flower-9677.herokuapp.com/%22>demo&lt;/a>%20and%20&lt;a%20href=%22https://github.com/skalb/trackbone/tree/version2">source</a>.</p>

<p>I think this is a big improvement over the first version, though it&rsquo;s not quite as good as it could be. Having the loadChildren logic in the views doesn&rsquo;t really make sense, but I&rsquo;m leaving those changes for when I implement permalinks.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to (easily) handle model relationships in Rails and Backbone.js]]></title>
    <link href="http://www.skalb.com/2012/04/23/how-to-easily-handle-model-relationships-in-rails-and-backbone-js/"/>
    <updated>2012-04-23T00:00:00-07:00</updated>
    <id>http://www.skalb.com/2012/04/23/how-to-easily-handle-model-relationships-in-rails-and-backbone-js</id>
    <content type="html"><![CDATA[<p>While playing around with Backbone.js, I couldn&rsquo;t find an easy way to build an app that used the RESTful hierarchy of my models. I think <a href="http://spinejs.com/docs/relations">Spine&rsquo;s</a> implementation is fairly straightforward.</p>

<p>I did find a relevant <a href="https://github.com/PaulUithol/Backbone-relational">active project</a>, but for my specific case the added complexity of an additional component and dependency didn&rsquo;t seem justified. Rails already does the hard part for me, I just need Backbone to call the correct Urls.</p>

<p>I wanted to learn more about Backbone, so I prototyped a very basic project management app using Rails and Backbone called Trackbone that I&rsquo;ll walk through in this post.</p>

<!--more-->


<p>Briefly, this is a single page three panel app with drill-downs:</p>

<ul>
    <li>Many projects</li>
    <li>Project has many Features</li>
    <li>Featurehas many Bugs</li>
</ul>


<p><a href="http://young-flower-9677.herokuapp.com/">Demo on Heroku</a>
<a href="https://github.com/skalb/trackbone/tree/version1">Source</a></p>

<p><strong>Rails backend:</strong></p>

<p>Rails controllers provide the REST API for our Backbone app. I haven&rsquo;t inlined them here since they only have a few modifications post-scaffolding, but you can view them <a href="https://github.com/skalb/trackbone/tree/version1/app/controllers">here</a></p>

<p>Modifications:</p>

<ul>
<li>Projects#index is moved to HomeController</li>
<li>Location is not returned in response after #create</li>
<li>Model is returned after #update</li>
</ul>


<p>``` ruby routes.rb
root :to => &ldquo;home#index&rdquo;</p>

<p>Trackbone::Application.routes.draw do
  resources :projects do</p>

<pre><code>resources :features do
  resources :bugs
end
</code></pre>

<p>  end
end
```</p>

<p>For setting up Backbone, the rails-backbone gem provides a good <a href="https://github.com/codebrew/backbone-rails/blob/master/README.md">guide</a>.</p>

<p>Originally, I scaffolded Backbone here as well. On review, I&rsquo;m not sure I would do that again. I think you&rsquo;ll end at a better design if you start from scratch.</p>

<p><strong>Creating Backbone Models:</strong></p>

<p>Features only exist in the context of a Project, so they should only be loaded for a specific Project and similarly for Bugs.</p>

<p>``` coffeescript javascripts/backbone/models/project.js.coffee
class Trackbone.Models.Project extends Backbone.Model
  paramRoot: &lsquo;project&rsquo;</p>

<p>  defaults:</p>

<pre><code>name: null
</code></pre>

<p>  loadFeatures: &ndash;></p>

<pre><code>@features = new Trackbone.Collections.FeaturesCollection([], {project_url: @url()});
</code></pre>

<p>class Trackbone.Collections.ProjectsCollection extends Backbone.Collection
  model: Trackbone.Models.Project
  url: &lsquo;/projects&rsquo;
```</p>

<p>On reflection, loadFeatures is poorly named. It&rsquo;s really more of an &lsquo;initialize&rsquo;, but anyways, calling that method will create a FeaturesCollection and pass in the Url for this project. You can see how this is used in the Features model</p>

<p>``` coffeescript javascripts/backbone/models/feature.js.coffee
class Trackbone.Models.Feature extends Backbone.Model
  paramRoot: &lsquo;feature&rsquo;</p>

<p>  defaults:</p>

<pre><code>name: null
</code></pre>

<p>  loadBugs: &ndash;></p>

<pre><code>@bugs = new Trackbone.Collections.BugsCollection([], {feature_url: @url()});
</code></pre>

<p>class Trackbone.Collections.FeaturesCollection extends Backbone.Collection
  model: Trackbone.Models.Feature
  initialize: (model, args) &ndash;></p>

<pre><code>@url = -&gt;
  args.project_url + "/features"
</code></pre>

<p>```</p>

<p>Using the project_url from args will prepend all RESTful requests made on the features model with projects/:project_id.</p>

<p>``` coffeescript javascripts/backbone/models/bug.js.coffee
class Trackbone.Models.Bug extends Backbone.Model
  paramRoot: &lsquo;bug&rsquo;</p>

<p>  defaults:</p>

<pre><code>name: null
</code></pre>

<p>class Trackbone.Collections.BugsCollection extends Backbone.Collection
  model: Trackbone.Models.Bug
  initialize: (model, args) &ndash;></p>

<pre><code>@url = -&gt;
  args.feature_url + "/bugs"
</code></pre>

<p>```</p>

<p><strong>Backbone Routers:</strong></p>

<p>Next we need to create the Projects router which will be the entry point into our single page app.</p>

<p>``` coffeescript javascripts/backbone/routers/projects_router.js.coffee
class Trackbone.Routers.ProjectsRouter extends Backbone.Router
  initialize: (options) &ndash;></p>

<pre><code>@projects = new Trackbone.Collections.ProjectsCollection()
@projects.reset options.projects
</code></pre>

<p>  routes:</p>

<pre><code>".*" : "index"
</code></pre>

<p>  index: &ndash;></p>

<pre><code>@view = new Trackbone.Views.Projects.IndexView(projects: @projects)
$("#list-projects").html(@view.render().el)

@newProjectView = new Trackbone.Views.Projects.NewView(collection: @projects)
$("#new-projects").html(@newProjectView.render().el)
</code></pre>

<p>```</p>

<p>Because we&rsquo;re not worrying about permalinks (yet! I&rsquo;ve started looking into this, and hope to create a follow-up post), we only need one catch-all route. We then pass in the respective models to our views.</p>

<p><strong>Listing projects:</strong></p>

<p>``` html views/projects/index.html.erb</p>

<h1>Trackbone</h1>


<hr>


<div class="container">
  <div id="new-projects"></div>
  <div id="list-projects"></div>
</div>


<div class="container">
  <div id="new-features"></div>
  <div id="list-features"></div>
</div>


<div class="container">
  <div id="new-bugs"></div>
  <div id="list-bugs"></div>
</div>




<script type="text/javascript">
  $(function() {
    window.router = new Trackbone.Routers.ProjectsRouter(
      { projects: <%= @projects.to_json.html_safe -%> }
    );
    Backbone.history.start();
  });
</script>


<p>```</p>

<p>There is a container, new, and list div for each model. Backbone will load data from our Rest API, build HTML using the Views and Templates and inject that HTML into those DIV elements. Note that we are passing in projects from Rails to the router. This allows us to grab data from the server when the page is first requested and save an additional call on page load. Since this is a single page app, this is the only Rails view we need.</p>

<p>To display our Project data we need three templates: index to list projects, project for a specific item, and new to create a project.</p>

<p><code>html javascripts/backbone/templates/shared/item.jst.ejs
&lt;td&gt;&lt;a href="#" class="select"&gt;&lt;%= name %&gt;&lt;/td&gt;
&lt;td&gt;[Destroy](#" class="destroy)&lt;/td&gt;
</code></p>

<p>``` html javascripts/backbone/templates/projects/index.jst.ejs</p>

<h1>Listing projects</h1>




<table id="projects-table">
  <tr>
    <th>Name</th>
    <th></th>
  </tr>
</table>




<br/>


<p>```</p>

<p>``` html javascripts/backbone/templates/projects/new.jst.ejs</p>

<h1>New project</h1>


<p><form id="new-project" name="project">
  <div class="field"></p>

<pre><code>&lt;label for="name"&gt; name:&lt;/label&gt;
&lt;input type="text" name="name" id="name" value="&lt;%= name %&gt;" &gt;
</code></pre>

<p>  </div></p>

<p>  <div class="actions"></p>

<pre><code>&lt;input type="submit" value="Create Project" /&gt;
</code></pre>

<p>  </div></p>

<p></form>
```</p>

<p>These should be fairly self-explanatory. Each template will also need a Backbone View as well.</p>

<p>``` coffeescript javascripts/backbone/views/projects/index_view.js.coffee
Trackbone.Views.Projects ||= {}</p>

<p>class Trackbone.Views.Projects.IndexView extends Backbone.View
  template: JST[&ldquo;backbone/templates/projects/index&rdquo;]</p>

<p>  initialize: () &ndash;></p>

<pre><code>@options.projects.bind('reset', @addAll)
@options.projects.bind('sync', @render)
</code></pre>

<p>  addAll: () =></p>

<pre><code>@options.projects.each(@addOne)
</code></pre>

<p>  addOne: (project) =></p>

<pre><code>view = new Trackbone.Views.Projects.ProjectView({model : project})
@$("tbody").append(view.render().el)
</code></pre>

<p>  render: =></p>

<pre><code>$(@el).html(@template(projects: @options.projects.toJSON()))
@addAll()

return this
</code></pre>

<p>```</p>

<p>This view receives the entire list of projects, renders the index view and appends a project view for each project.</p>

<p>``` coffeescript javascripts/backbone/views/projects/new_view.js.coffee
Trackbone.Views.Projects ||= {}</p>

<p>class Trackbone.Views.Projects.NewView extends Backbone.View
  template: JST[&ldquo;backbone/templates/projects/new&rdquo;]</p>

<p>  events:</p>

<pre><code>"submit #new-project": "save"
</code></pre>

<p>  save: (e) &ndash;></p>

<pre><code>e.preventDefault()
e.stopPropagation()

name = $("#new-project #name").val()
if name
  $("#new-project #name").val('')
  @collection.create(name: name)
</code></pre>

<p>  render: &ndash;></p>

<pre><code>$(@el).html(@template())

return this
</code></pre>

<p>```</p>

<p>The new view simply providers a handler for creating a new project within the collection. The create method actually does three things: creates the model, POSTs the model to the server, and adds the model to the collection.</p>

<p>``` coffeescript javascripts/backbone/views/projects/project_view.js.coffee
Trackbone.Views.Projects ||= {}</p>

<p>class Trackbone.Views.Projects.ProjectView extends Backbone.View
  template: JST[&ldquo;backbone/templates/shared/item&rdquo;]</p>

<p>  events:</p>

<pre><code>"click .select" : "select"
"click .destroy" : "destroy"
</code></pre>

<p>  tagName: &ldquo;tr&rdquo;
  className: &ldquo;item&rdquo;</p>

<p>  select: () &ndash;></p>

<pre><code>window.toggleSelected(@el)
@model.loadFeatures()
do (@model) -&gt;
  @model.features.fetch success: -&gt;
    featuresView = new Trackbone.Views.Features.IndexView(features: @model.features)
    $("#list-features").html(featuresView.render().el)

    # We should probably only render this once instead of each load
    newFeaturesView = new Trackbone.Views.Features.NewView(collection: @model.features)
    $("#new-features").html(newFeaturesView.render().el)

    $("#list-bugs").html('')
    $("#new-bugs").html('')
@model.features.fetch()
</code></pre>

<p>  destroy: () &ndash;></p>

<pre><code>@model.destroy()
this.remove()

return false
</code></pre>

<p>  render: &ndash;></p>

<pre><code>$(@el).html(@template(@model.toJSON() ))
return this
</code></pre>

<p>```</p>

<p>This view is really the heart of the app. Every time a Project is selected, we&rsquo;ll display the Features for that Project by calling fetch() and binding to success().</p>

<p>I&rsquo;m not going to inline the templates and views for Features and Bugs since they are more or less identical, but feel free to browse through all the <a href="https://github.com/skalb/trackbone/tree/version1/app/assets/javascripts/backbone">client side code</a></p>

<p>Again, here&rsquo;s a working <a href="http://young-flower-9677.herokuapp.com/">demo</a>.</p>

<p>Please provide any feedback you have in the comments. Was this useful? Too long? Too much/too little code inline? I&rsquo;m currently working on a couple more entires that will build on this one as I&rsquo;m learning more about Backbone.js, so feedback is definitely useful.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Creating a document sharing site with Meteor.js]]></title>
    <link href="http://www.skalb.com/2012/04/16/creating-a-document-sharing-site-with-meteor-js/"/>
    <updated>2012-04-16T00:00:00-07:00</updated>
    <id>http://www.skalb.com/2012/04/16/creating-a-document-sharing-site-with-meteor-js</id>
    <content type="html"><![CDATA[<p><strong>Background:</strong></p>

<p>“Meteor is a set of new technologies for building top-quality web apps in a fraction of the time, whether you&rsquo;re an expert developer or just getting started.”
&ndash; <a href="http://www.meteor.com">Meteor.com</a></p>

<p><strong>Goal:</strong></p>

<p>Create and deploy a real time document sharing website. The final product is at: <a href="http://docshare-tutorial.meteor.com">docshare-tutorial.meteor.com</a>.</p>

<!--more-->


<p><strong>Updated: Source code at <a href="https://github.com/skalb/docshare-tutorial">https://github.com/skalb/docshare-tutorial</a></strong></p>

<p><strong>Spec:</strong></p>

<ul>
<li>Single page app with two sections</li>
<li>Section 1

<ul>
<li>List of documents each with edit and delete buttons</li>
<li>Create new document button with name input</li>
</ul>
</li>
<li>Section 2

<ul>
<li>Text area of the document currently being edited</li>
</ul>
</li>
</ul>


<p><strong>Prerequisites:</strong></p>

<ul>
<li>Install Meteor</li>
</ul>


<p><code>bash
$ curl install.meteor.com | /bin/sh
</code></p>

<p><strong>Step 1: Getting things started</strong></p>

<p>Lets create the app:</p>

<p><code>bash
meteor create docshare-tutorial
</code></p>

<p>Now, start the meteor server:</p>

<p><code>bash
cd docshare-tutorial
meteor
</code></p>

<p>You should see the default site at <a href="http://localhost:3000/">http://localhost:3000</a>:</p>

<p>Lastly, add the other packages we are going to use</p>

<p><code>bash
meteor add coffeescript
meteor add backbone
</code></p>

<p><strong>Step 2: Setting up the project</strong></p>

<p>Go ahead and delete <strong>docshare-tutorial.js</strong> and empty out the contents of <strong>docshare-tutorial.html</strong>.</p>

<p>Meteor lets you separate client and server code in 2 different ways:</p>

<ol>
<li>Using the Meteor.is_client and Meteor.is_server flags</li>
<li>Place client and server Javascript in the /client and /server folders, respectively. Any Javascript at the root level with run on both.</li>
</ol>


<p>I prefer method 2 since it feels a bit cleaner to me, but feel free to instead combine everything into one file. Create <strong>docshare-tutorial.coffee</strong>  at the root and <strong>client.coffee</strong>  in /client folder and <strong>server.coffee</strong> in the /server folder.</p>

<p><strong>Step 3: Server</strong></p>

<p>Collections in Meteor are schemaless. We want our documents collection to be available to both the server and the client so we’ll add it to the root level.</p>

<p>``` coffeescript docshare-tutorial.coffee
 @Documents = new Meteor.Collection(&ldquo;documents&rdquo;)</p>

<p>```</p>

<p>Our document object will have two fields: name and text. Let’s create a sample document on startup.</p>

<p>``` coffeescript server.coffee
Meteor.startup &ndash;>
  if Documents.find().count() is 0</p>

<pre><code>Documents.insert
  name: "Sample doc"
  text: "Write here..."
</code></pre>

<p>```</p>

<p>Now, if you restart the meteor server, you’ll be able to access that document in the browser. Try this in the developer console:</p>

<p><code>javascript console
Documents.findOne()
</code></p>

<p>You will see an object with the properties we just created. This is the only time you should need to restart the meteor server.</p>

<p><strong>Step 4: Client HTML</strong></p>

<p>Here’s we’ll define our head and body. The body will render two templates: documentList and documentView.</p>

<p>```
<head>
  <title>docshare</title>
</head>
<body>
  
  <hr>
  
</body></p>

<p>```</p>

<p>Next, create the two templates needed to display the documents: documentList and document.</p>

<p>```
<template name="documentList">
  <h1>Welcome to document sharing!</h1>
  <div></p>

<pre><code>
  

</code></pre>

<p>  </div>
  <div id="createDocument"></p>

<pre><code>Name: &lt;input type="text" id="new-document-name" placeholder="New document" /&gt;&lt;input type="button" id="new-document" value="create"/&gt;
</code></pre>

<p>  </div>
</template>
```</p>

<p>Here we are using the built in Handlebars iterator #each to render the individual document objects. Finally, there’s a input field and create button to add a new document.</p>

<p>Now add the template to list the documents names each with an edit and delete button. We’ll also use a template method to determine which document is selected.</p>

<p>```
<template name="document">
  <div class="document "></p>

<pre><code>&lt;p&gt;

&lt;input type="button" id="edit-document" value="Edit"/&gt;
&lt;input type="button" id="delete-document" value="Delete"/&gt;
&lt;/p&gt;
</code></pre>

<p>   </div>
</template>
```</p>

<p>Lastly, let’s add the actual text field that the users can edit.</p>

<p>```
<template name="documentView">
  
  </p>

<pre><code>&lt;div&gt;
  &lt;p&gt;&lt;/p&gt;
    &lt;textarea id="document-text" rows="10" cols="80"&gt;&lt;/textarea&gt;
&lt;/div&gt;
</code></pre>

<p>   
   
</template>
```</p>

<p>Note that this will only be rendered if a document is currently selected. Having both an #if and a #with seems redundant, but I didn’t see a better way. Based off the Handlebars documentation, I should only need the #if, but that doesn’t work.</p>

<p><strong>Step 5: Client Coffeescript</strong></p>

<p>First, we’ll setup a Backbone router to allow us to keep track of which document we’re viewing. This will allow us to support page refreshes and permalinking to documents.</p>

<p>``` coffeescript client.coffee
DocumentsRouter = Backbone.Router.extend(
  routes:</p>

<pre><code>":document_id": "main"
</code></pre>

<p>  main: (document_id) &ndash;></p>

<pre><code>Session.set "document_id", document_id
</code></pre>

<p>  setDocument: (document_id) &ndash;></p>

<pre><code>@navigate(document_id, true)
</code></pre>

<p>)</p>

<p>Router = new DocumentsRouter</p>

<p>Meteor.startup &ndash;>
  Backbone.history.start pushState: true
```</p>

<p>Basically this will store the document_id into the Meteor session whenever the user navigates to a URL or form /:document_id. If you’re not familar with Backbone, don’t worry about this, or read up at <a href="http://backbonejs.org/">http://backbonejs.org/</a></p>

<p>We are also using Meteor.startup again here but for a different purpose. On the client side it will run after DOM is loaded every time. I think it would be more clear if this method didn’t mean different things based on context.</p>

<p>Next, we need to define where the documentList template gets its data and handle the create new button</p>

<p>``` coffeescript client.coffee
Template.documentList.documents = &ndash;>
  Documents.find({},</p>

<pre><code>sort:
  name: 1
</code></pre>

<p>  )</p>

<p>Template.documentList.events =
  &lsquo;click #new-document&rsquo;: (e) &ndash;></p>

<pre><code>name = $('#new-document-name').val()
if name
  Documents.insert(
    name: name
    text: ""
  )
</code></pre>

<p>```</p>

<p>Notice that we’re sorting the documents by name. Each time a new document is added it will be correctly injected into the DOM. The entire list is not recreated. There is also a bit of validation to make sure the name exists.</p>

<p>Documents.insert (and all collection operations) are non-blocking when called client side. Meteor will go ahead and insert the data to the local client and can optionally call a callback with an object identifier or error message after the real operation finishes. This is invisible to the user, of course.</p>

<p>Next, define the selected property and event handlers for edit and delete:</p>

<p>``` coffeescript client.coffee
Template.document.events =
  &lsquo;click #delete-document&rsquo;: (e) &ndash;></p>

<pre><code>Documents.remove(@_id)
</code></pre>

<p>  &lsquo;click #edit-document&rsquo;: (e) &ndash;></p>

<pre><code>Router.setDocument(@_id)
</code></pre>

<p>Template.document.selected = &ndash;>
  if Session.equals(&ldquo;document_id&rdquo;, @_id) then &ldquo;selected&rdquo; else &ldquo;&rdquo;
```</p>

<p>Note that in handlers for events the this object is the actual Document object.</p>

<p>Next, define the selectedDocument using the id stored in the session and update the text of that document when the user presses a key.</p>

<p>``` coffeescript client.coffee
Template.documentView.selectedDocument = &ndash;>
  document_id = Session.get(&ldquo;document_id&rdquo;)
  Documents.findOne(</p>

<pre><code>_id: document_id
</code></pre>

<p>  )</p>

<p>Template.documentView.events =
  &lsquo;keyup #document-text&rsquo;: (e) &ndash;></p>

<pre><code># @_id should work here, but it doesn't
sel = _id: Session.get("document_id")
mod = $set: text: $('#document-text').val()
Documents.update(sel, mod)
</code></pre>

<p>```</p>

<p>Meteor acknowledges in their docs: “For now, the event handler gets the template data from the top level of the current template, not the template data from the template context of the element that triggered the event. This will be changing.” This is why we have to pull the id from the session.</p>

<p>Lastly, add the css style for the selected div:
<code>css docshare-tutorial.css
.selected {
  background-color: yellow;
}
</code></p>

<p><strong>Conclusion:</strong>
That’s it, done! 50 lines of HTML and 50 lines of Coffeescript for a very basic Google docs clone.</p>

<p>To test it out open two browsers and type!</p>
]]></content>
  </entry>
  
</feed>
