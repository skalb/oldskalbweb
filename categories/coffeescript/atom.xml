<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: CoffeeScript | skalb.com]]></title>
  <link href="http://www.skalb.com/categories/coffeescript/atom.xml" rel="self"/>
  <link href="http://www.skalb.com/"/>
  <updated>2013-07-05T18:57:42-07:00</updated>
  <id>http://www.skalb.com/</id>
  <author>
    <name><![CDATA[Sameer Kalburgi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Testing Backbone Routers in Meteor with Mocha]]></title>
    <link href="http://www.skalb.com/2012/08/20/testing-backbone-routers-in-meteor-with-mocha/"/>
    <updated>2012-08-20T00:00:00-07:00</updated>
    <id>http://www.skalb.com/2012/08/20/testing-backbone-routers-in-meteor-with-mocha</id>
    <content type="html"><![CDATA[<p>One of the downsides of Meteor and perhaps strongest complaint is that it doesn't play nicely with existing NodeJS modules. You're forced to use the available SmartPackages (or build one). This is a problem since the Mocha environment runs without the browser and doesn't have access to the libraries included by the SmartPackage.</p>

<!--more-->


<p><em>Here's a previous <a title="Testing with Meteor, CoffeeScript and Mocha" href="http://www.skalb.com/2012/08/19/testing-with-meteor-coffeescript-and-mocha/">post</a> describing how to setup everything</em></p>

<p>Creating the project:</p>

<p><code>bash
meteor create mocha-router
meteor add backbone
meteor add coffeescript
cd mocha-router
mkdir client
mkdir server
mkdir tests
cd tests
mkdir lib
</code></p>

<p>When I first installed the modules, I installed them in my project root, but this caused Meteor to try to load them in the both the client/server environment which crashed the Meteor server. Luckily, Meteor will ignore anything in the tests folder so we can install the necessary modules there.</p>

<p><code>bash
npm install should
npm install backbone
mocha *.coffee --compilers coffee:coffee-script
</code></p>

<p>My goal was to create a very basic Backbone router test. Normally, I'd define the router like so:</p>

<p>``` coffeescript
SampleRouter = @Backbone.Router.extend(
  routes:</p>

<pre><code>"": "index"
</code></pre>

<p>  index: ->
)
new SampleRouter
```</p>

<p>This won't work when running the Mocha tests because it assumes the Meteor framework is present to load Backbone. I solved this by creating a factory for the router and injecting the Backbone module.</p>

<p>Note, I need to put this module in tests/lib so Meteor will make sure to load it first</p>

<p>lib/sample_router_factory.coffee:
``` coffeescript
root = exports ? this</p>

<p>class SampleRouterFactory
  constructor: (@Backbone) -></p>

<p>  getRouter: () -></p>

<pre><code>SampleRouter = @Backbone.Router.extend(
  routes:
    "": "index"

  index: -&gt;
    Session.set "test", "test"
)
new SampleRouter
</code></pre>

<p>root.SampleRouterFactory = SampleRouterFactory
```</p>

<p>Exports is a global object accessible in the nodeJS environment that Mocha runs in. See this <a href="http://visionmedia.github.com/masteringnode/book.html">ebook</a> for more details.</p>

<p>This module will now create a class that will return a new instance of the SampleRouter.</p>

<p>Now, let's look at the test case:</p>

<p>tests/sample_router_factory_test.coffee
``` coffeescript
should = require('should')
Backbone = require('backbone')
SampleRouterFactory = require('../client/lib/sample_router_factory').SampleRouterFactory</p>

<p>describe "SampleRouter", ->
  factory = new SampleRouterFactory(Backbone)
  router = factory.getRouter(Backbone)
  it "should have an index router", -></p>

<pre><code>router.routes[''].should.equal('index')
</code></pre>

<p>```</p>

<p>Lastly, in the actual Meteor app I create the app a similar way:</p>

<p>mocha-router.coffee
<code>coffeescript
Meteor.startup -&gt;
  factory = new SampleRouterFactory(Backbone)
  router = factory.getRouter(Backbone)
</code></p>

<p>Again, there's no need to require either Backbone (loaded as a SmartPackage) or the actual SampleRouterFactory because Meteor treats all of your CoffeeScript files as a single file and consequently scope.</p>

<p><a href="https://github.com/skalb/meteor-examples/tree/master/mocha-router">Source code here.</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Testing with Meteor, CoffeeScript and Mocha]]></title>
    <link href="http://www.skalb.com/2012/08/19/testing-with-meteor-coffeescript-and-mocha/"/>
    <updated>2012-08-19T00:00:00-07:00</updated>
    <id>http://www.skalb.com/2012/08/19/testing-with-meteor-coffeescript-and-mocha</id>
    <content type="html"><![CDATA[<p>Despite no mention in the official <a href="http://docs.meteor.com/">Meteor docs</a>, adding unit tests is fairly easy. For some reason, they don't mention this but any files in the tests/ folder will be ignored by the Meteor server.</p>

<!--more-->


<p>What you'll need:</p>

<ul>
    <li><a href="https://github.com/meteor/meteor">Meteor</a></li>
    <li><a href="https://github.com/isaacs/npm">Npm</a></li>
    <li><a href="https://github.com/visionmedia/mocha">Mocha</a></li>
</ul>


<div>Optional:</div>


<div>
<ul>
    <li><a href="http://growl.info/">Growl</a> (for notifications from mocha watch)</li>
</ul>
</div>


<div>Getting everything running:</div>


<p><code>bash
meteor create mocha
cd mocha
meteor add coffeescript
</code></p>

<p>Setting up Mocha to watch our coffee files and send Growl notifications:</p>

<p>``` bash</p>

<p>mocha tests/*.coffee -w -G --compilers coffee:coffee-script</p>

<p>```</p>

<p>Now to create a sample test:</p>

<p>``` coffeescript test.coffee
describe "Array", ->
  describe "#indexOf()", -></p>

<pre><code>it "should return -1 when the value is not present", -&gt;
  assert.equal -1, [1, 2, 3].indexOf(1)
  assert.equal -1, [1, 2, 3].indexOf(0)
</code></pre>

<p>```</p>

<p>Mocha should notice the file change and run the tests showing you the passing test.</p>

<p><a href="https://github.com/skalb/meteor-examples/tree/master/mocha">Source code here.</a></p>

<p>Some notes:</p>

<ul>
    <li>The growl notification didn't work for me, but I assume that's because I'm using an old version.</li>
    <li>When using Mocha watch, sometimes a failing test result would be outputted many times</li>
    <li><a href="https://github.com/pivotal/jasmine">Jasmine</a> should also work fine</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Handling permalinks in Backbone.js with Routers]]></title>
    <link href="http://www.skalb.com/2012/04/30/handling-permalinks-in-backbone-js-with-routers/"/>
    <updated>2012-04-30T00:00:00-07:00</updated>
    <id>http://www.skalb.com/2012/04/30/handling-permalinks-in-backbone-js-with-routers</id>
    <content type="html"><![CDATA[<p>This post is part of a series:</p>

<ul>
    <li><a title="How to (easily) handle model relationships in Rails and Backbone.js" href="http://www.skalb.com/2012/04/23/how-to-easily-handle-model-relationships-in-rails-and-backbone-js/">First post</a></li>
    <li><a title="Extending and refactoring views in Backbone.js" href="http://www.skalb.com/2012/04/26/extending-and-refactoring-views-in-backbone/">Second post</a></li>
</ul>


<p>One of the missing features in my prototype was handling of permalinks. To make things easy, I originally removed all the routes and added click handlers instead. In retrospect that was a mistake. Instead of having the app logic tangled up with click handlers, it would have been much more straightforward to define routes and use links.</p>

<p>Here’s the <a href="https://github.com/skalb/trackbone">source</a> and <a href="http://young-flower-9677.herokuapp.com/">demo</a>.</p>

<!--more-->


<p>In this post, I’m going to explain the  Backbone router step by step. First, I need to actually define what routes I want:</p>

<p>I need:</p>

<ul>
    <li>Home page -> Load list of projects</li>
    <li>Selected project -> Load list of projects and features</li>
    <li>Selected feature -> Load list of projects, features, and bugs</li>
</ul>


<p><code>coffeescript
routes:
  ".*"  : "showProjects"
  "projects/:project_id" : "showProjects"
  "projects/:project_id/features/:feature_id/*" : "showProjects"
</code></p>

<p>Notice that all my routes point to the same function. The only difference is that the project_id and feature_id variables will be undefined. JavaScript won’t complain if your function call doesn’t match the function signature. It will just set them undefined.</p>

<p>Now let’s look at showProjects.</p>

<p>``` coffeescript
showProjects: (project_id, feature_id, bug_id) ->
  @renderViews(@projects, project_id, "Projects")</p>

<p>  if project_id
    @loadChildren(@projects, project_id, [feature_id, bug_id], "loadFeatures")
```</p>

<p>My original goal was to create a helper method that would support an abitrary length chain of loading children. That is, loadChildren will call loadFeatures which will then call loadChildren again etc. The final implementation isn’t quite that generic since it requires me to construct the individual item_ids at the start.</p>

<p>As I was finishing this prototype , I managed to remove all duplicate code by creating some helper methods.</p>

<p>``` coffeescript
clearType: (model) ->
  $("#list-#{model}").html('')
  $("#new-#{model}").html('')</p>

<p>renderView: (selector, view) ->
  $(selector).html(view.render().el)</p>

<p>renderViews: (items, item_id, type) ->
  indexView = new Trackbone.Views.IndexView(items: items, id: item_id, type: type)
  @renderView("#list-#{type.toLowerCase()}", indexView)</p>

<p>  newView = new Trackbone.Views.NewView(collection: items, type: type)
  @renderView("#new-#{type.toLowerCase()}", newView)
```</p>

<p>And now let’s look at loadChildren:</p>

<p><code>coffeescript
loadChildren: (items, item_id, child_ids, callback) -&gt;
  item = items.get(item_id)
  item.loadChildren()
  item.children.fetch(
    success: =&gt;
      @[callback](item.children, child_ids.shift(), child_ids)
  )
  item.children.fetch()
</code></p>

<p>Okay, why am I indexing into the object with a string instead of just passing the function in directly. Well, because the fat arrow wasn’t working as expected. Either I was doing something wrong or there's a bug in the coffee-rails interpreter because js2coffee gave me a different result.</p>

<p>The full router:</p>

<p>``` coffeescript
class Trackbone.Routers.ProjectsRouter extends Backbone.Router
  initialize: (options) ->
    @projects = new Trackbone.Collections.ProjectsCollection()
    @projects.reset options.projects</p>

<p>  routes:
    ".<em>"  : "showProjects"
    "projects/:project_id" : "showProjects"
    "projects/:project_id/features/:feature_id/</em>" : "showProjects"</p>

<p>  clearType: (model) ->
    $("#list-#{model}").html('')
    $("#new-#{model}").html('')</p>

<p>  loadChildren: (items, item_id, child_ids, callback) ->
    item = items.get(item_id)
    item.loadChildren()
    item.children.fetch(
      success: =>
        @<a href="item.children,%20child_ids.shift(">callback</a>, child_ids)
    )
    item.children.fetch()</p>

<p>  renderView: (selector, view) ->
    $(selector).html(view.render().el)</p>

<p>  renderViews: (items, item_id, type) ->
    indexView = new Trackbone.Views.IndexView(items: items, id: item_id, type: type)
    @renderView("#list-#{type.toLowerCase()}", indexView)</p>

<p>    newView = new Trackbone.Views.NewView(collection: items, type: type)
    @renderView("#new-#{type.toLowerCase()}", newView)</p>

<p>  showProjects: (project_id, feature_id, bug_id) ->
    @renderViews(@projects, project_id, "Projects")</p>

<p>    if project_id
      @loadChildren(@projects, project_id, [feature_id, bug_id], "loadFeatures")</p>

<p>  loadFeatures: (features, feature_id, child_ids) ->
    @renderViews(features, feature_id, "Features")</p>

<p>    if feature_id
      @loadChildren(features, feature_id, child_ids, "loadBugs")
    else
      @clearType("bugs")</p>

<p>  loadBugs: (bugs, bug_id, child_ids) ->
    @renderViews(bugs, bug_id, "Bugs")
```</p>

<p>I also needed to tweak my item view to include the correct url for the select link.</p>

<p>``` coffeescript
Trackbone.Views.Projects ||= {}</p>

<p>class Trackbone.Views.ItemView extends Backbone.View
  template: JST["backbone/templates/item"]</p>

<p>  events:
    "click .destroy" : "destroy"</p>

<p>  tagName: "tr"
  className: "item"</p>

<p>  destroy: () ->
    @model.destroy()
    this.remove()</p>

<p>    return false</p>

<p>  render: ->
    name = @model.get("name")
    id = @model.get("id")
    url = "#{@model.collection.url()}/#{id}"
    $(@el).html(@template(name: name, id: id, url: url))
    if (@options.selected)
      window.toggleSelected(@el)
    return this</p>

<p>```</p>

<p>Again, here’s the <a href="https://github.com/skalb/trackbone">source</a> and <a href="http://young-flower-9677.herokuapp.com/">demo</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Extending and refactoring views in Backbone.js]]></title>
    <link href="http://www.skalb.com/2012/04/26/extending-and-refactoring-views-in-backbone/"/>
    <updated>2012-04-26T00:00:00-07:00</updated>
    <id>http://www.skalb.com/2012/04/26/extending-and-refactoring-views-in-backbone</id>
    <content type="html"><![CDATA[<p>In a <a href="http://www.skalb.com/2012/04/23/how-to-easily-handle-model-relationships-in-rails-and-backbone-js/" >previous post</a>, I built an example single page app using Backbone. One thing that bothered me was how similar the views are, yet didn't share any code. I think part of this was that I originally scaffolded the entire app and worked backwards.</p>

<!--more-->


<p>For example, here's Project vs Feature Index Templates:
``` html</p>

<h1>Listing projects</h1>




<table id="projects-table">
  <tr>
    <th>Name</th>
    <th></th>
  </tr>
</table>




<br/>


<p>```</p>

<p>vs.</p>

<p>``` html</p>

<h1>Listing features</h1>




<table id="features-table">
  <tr>
    <th>Name</th>
    <th></th>
  </tr>
</table>




<br/>


<p>```</p>

<p>This is easily refactored to:
``` html</p>

<h1>Listing <%= type %></h1>




<table id="items-table">
  <tr>
    <th>Name</th>
    <th></th>
  </tr>
</table>




<br/>


<p><code>
Similarly, the New View changed from:
</code> html</p>

<h1>New project</h1>


<p><form id="new-project" name="project">
  <div class="field"></p>

<pre><code>&lt;label for="name"&gt; name:&lt;/label&gt;
&lt;input type="text" name="name" id="name" value="&lt;%= name %&gt;" &gt;
</code></pre>

<p>  </div></p>

<p>  <div class="actions"></p>

<pre><code>&lt;input type="submit" value="Create Project" /&gt;
</code></pre>

<p>  </div></p>

<p></form>
<code>
to
</code> html</p>

<h1>New <%= type %></h1>


<p><form id="new-item">
  <div class="field"></p>

<pre><code>&lt;label for="name"&gt; name:&lt;/label&gt;
&lt;input type="text" name="name" id="name" value="&lt;%= name %&gt;" &gt;
</code></pre>

<p>  </div></p>

<p>  <div class="actions"></p>

<pre><code>&lt;input type="submit" value="Create &lt;%= type %&gt;" /&gt;
</code></pre>

<p>  </div></p>

<p></form>
```</p>

<p>Great, that was easy and now I just reduced my total Templates. To share functionality between the Views I needed to create a base View class:</p>

<p>``` coffeescript
Trackbone.Views ||= {}</p>

<p>class Trackbone.Views.IndexView extends Backbone.View
  template: JST["backbone/templates/index"]</p>

<p>  initialize: () -></p>

<pre><code>@options.items.bind('reset', @addAll)
@options.items.bind('sync', @addAll)
</code></pre>

<p>  addAll: () =></p>

<pre><code># This shouldn't be needed, but for some reason
# lists are rendered twice
@$("tbody").html('')

@options.items.each(@addOne)
</code></pre>

<p>  addOne: (item) =></p>

<pre><code>item.collection = @options.items
@$("tbody").append(@getView({model: item}).render().el)
</code></pre>

<p>  render: =></p>

<pre><code>$(@el).html(@template(type: @options.type))
@addAll()

return this
</code></pre>

<p>```</p>

<p>First thing to note is that this View has an initialize method. But that method will never be called automatically because we're going to extend this View into a new class and create an instance of the subclass instead. Also note that we're calling a function getView() that isn't defined in this class.</p>

<p>``` coffeescript</p>

<h1>= require ../index_view</h1>

<p>Trackbone.Views.Projects ||= {}</p>

<p>class Trackbone.Views.Projects.IndexView extends Trackbone.Views.IndexView
  initialize: () -></p>

<pre><code>super
@options.type = "Projects"
</code></pre>

<p>  getView: (options) =></p>

<pre><code>new Trackbone.Views.Projects.ProjectView(options)
</code></pre>

<p>```</p>

<p>We can call the into the parent class by using super in this view's initialize. This is just a <a href="http://coffeescript.org/#classes">CoffeeScript shortcut</a> to apply the same arguments to the parent's constructor. I've also explicitly required the parent View class since Rails does not guarantee which order JavaScript files will be loaded in the browser. The getView function here creates the correct ItemView based off the Project model.</p>

<p>The New item View shown below is generic enough that it did not need to be extended for each model.</p>

<p>``` coffeescript
Trackbone.Views.Projects ||= {}</p>

<p>class Trackbone.Views.NewView extends Backbone.View
  template: JST["backbone/templates/new"]</p>

<p>  events:</p>

<pre><code>"submit #new-item": "save"
</code></pre>

<p>  save: (e) -></p>

<pre><code>e.preventDefault()
e.stopPropagation()

name = @.$("#new-item #name").val()
if name
  $("#new-item #name").val('')
  @collection.create(name: name)
</code></pre>

<p>  render: -></p>

<pre><code>$(@el).html(@template(type: @options.type))

return this
</code></pre>

<p>```</p>

<p>The Item View is a bit trickier because it contained the select handling for when an item was clicked. To be able to reuse the handling, I had to make the load methods consistently named loadChildren as shown below.</p>

<p>``` coffeescript
class Trackbone.Models.Project extends Backbone.Model
  paramRoot: 'project'</p>

<p>  defaults:</p>

<pre><code>name: null
</code></pre>

<p>  loadChildren: -></p>

<pre><code>@children = new Trackbone.Collections.FeaturesCollection([], {project_url: @url()});
</code></pre>

<p>class Trackbone.Collections.ProjectsCollection extends Backbone.Collection
  model: Trackbone.Models.Project
  url: '/projects'
```</p>

<p>One thing to point out in the Item View base class is that I believe I could have used the <a href="http://coffeescript.org/#fat_arrow">fat arrow</a> to retain the correct context.</p>

<p>``` coffeescript
Trackbone.Views.Projects ||= {}</p>

<p>class Trackbone.Views.ItemView extends Backbone.View
  template: JST["backbone/templates/item"]</p>

<p>  events:</p>

<pre><code>"click .select" : "select"
"click .destroy" : "destroy"
</code></pre>

<p>  tagName: "tr"
  className: "item"</p>

<p>  select: () -></p>

<pre><code>if @model.loadChildren
  window.toggleSelected(@el)
  @model.loadChildren()
  do (@model, @renderChildren) -&gt;
    @model.children.fetch(
      success: @renderChildren(@model.children)
    )
    @model.children.fetch()
</code></pre>

<p>  destroy: () -></p>

<pre><code>@model.destroy()
this.remove()

return false
</code></pre>

<p>  render: -></p>

<pre><code>$(@el).html(@template(@model.toJSON() ))
return this
</code></pre>

<p>```</p>

<p>Now the actual Project view only had to define how to render it's children.</p>

<p>``` coffeescript</p>

<h1>= require ../item_view</h1>

<p>Trackbone.Views.Projects ||= {}</p>

<p>class Trackbone.Views.Projects.ProjectView extends Trackbone.Views.ItemView
  template: JST["backbone/templates/item"]</p>

<p>  renderChildren: (children) -></p>

<pre><code>featuresView = new Trackbone.Views.Features.IndexView(items: children)
$("#list-features").html(featuresView.render().el)

# We should probably only render this once instead of each load
newFeaturesView = new Trackbone.Views.NewView(collection: children, type: "Features")
$("#new-features").html(newFeaturesView.render().el)

$("#list-bugs").html('')
$("#new-bugs").html('')
</code></pre>

<p>```</p>

<p>Again, here's the <a href="http://young-flower-9677.herokuapp.com/">demo</a> and <a href="https://github.com/skalb/trackbone/tree/version2">source</a>.</p>

<p>I think this is a big improvement over the first version, though it's not quite as good as it could be. Having the loadChildren logic in the views doesn't really make sense, but I'm leaving those changes for when I implement permalinks.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to (easily) handle model relationships in Rails and Backbone.js]]></title>
    <link href="http://www.skalb.com/2012/04/23/how-to-easily-handle-model-relationships-in-rails-and-backbone-js/"/>
    <updated>2012-04-23T00:00:00-07:00</updated>
    <id>http://www.skalb.com/2012/04/23/how-to-easily-handle-model-relationships-in-rails-and-backbone-js</id>
    <content type="html"><![CDATA[<p>While playing around with Backbone.js, I couldn't find an easy way to build an app that used the RESTful hierarchy of my models. I think <a href="http://spinejs.com/docs/relations">Spine's</a> implementation is fairly straightforward.</p>

<p>I did find a relevant<a href="https://github.com/PaulUithol/Backbone-relational">active project</a>, but for my specific case the added complexity of an additional component and dependency didn't seem justified. Rails already does the hard part for me, I just need Backbone to call the correct Urls.</p>

<p>I wanted to learn more about Backbone, so I prototyped a very basic project management app using Rails and Backbone called Trackbone that I'll walk through in this post.</p>

<!--more-->


<p>Briefly, this is a single page three panel app with drill-downs:</p>

<ul>
    <li>Many projects</li>
    <li>Project has many Features</li>
    <li>Featurehas many Bugs</li>
</ul>


<p><a href="http://young-flower-9677.herokuapp.com/">Demo on Heroku</a>
<a href="https://github.com/skalb/trackbone/tree/version1">Source</a></p>

<p><strong>Rails backend:</strong></p>

<p>Rails controllers provide the REST API for our Backbone app. I haven't inlined them here since they only have a few modifications post-scaffolding, but you can view them <a href="https://github.com/skalb/trackbone/tree/version1/app/controllers">here</a></p>

<p>Modifications:</p>

<ul>
<li>Projects#index is moved to HomeController</li>
<li>Location is not returned in response after #create</li>
<li>Model is returned after #update</li>
</ul>


<p>``` ruby routes.rb
root :to => "home#index"</p>

<p>Trackbone::Application.routes.draw do
  resources :projects do</p>

<pre><code>resources :features do
  resources :bugs
end
</code></pre>

<p>  end
end
```</p>

<p>For setting up Backbone, the rails-backbone gem provides a good <a href="https://github.com/codebrew/backbone-rails/blob/master/README.md">guide</a>.</p>

<p>Originally, I scaffolded Backbone here as well. On review, I'm not sure I would do that again. I think you'll end at a better design if you start from scratch.</p>

<p><strong>Creating Backbone Models:</strong></p>

<p>Features only exist in the context of a Project, so they should only be loaded for a specific Project and similarly for Bugs.</p>

<p>``` coffeescript javascripts/backbone/models/project.js.coffee
class Trackbone.Models.Project extends Backbone.Model
  paramRoot: 'project'</p>

<p>  defaults:</p>

<pre><code>name: null
</code></pre>

<p>  loadFeatures: -></p>

<pre><code>@features = new Trackbone.Collections.FeaturesCollection([], {project_url: @url()});
</code></pre>

<p>class Trackbone.Collections.ProjectsCollection extends Backbone.Collection
  model: Trackbone.Models.Project
  url: '/projects'
```</p>

<p>On reflection, loadFeatures is poorly named. It's really more of an 'initialize', but anyways, calling that method will create a FeaturesCollection and pass in the Url for this project. You can see how this is used in the Features model</p>

<p>``` coffeescript javascripts/backbone/models/feature.js.coffee
class Trackbone.Models.Feature extends Backbone.Model
  paramRoot: 'feature'</p>

<p>  defaults:</p>

<pre><code>name: null
</code></pre>

<p>  loadBugs: -></p>

<pre><code>@bugs = new Trackbone.Collections.BugsCollection([], {feature_url: @url()});
</code></pre>

<p>class Trackbone.Collections.FeaturesCollection extends Backbone.Collection
  model: Trackbone.Models.Feature
  initialize: (model, args) -></p>

<pre><code>@url = -&gt;
  args.project_url + "/features"
</code></pre>

<p>```</p>

<p>Using the project_url from args will prepend all RESTful requests made on the features model with projects/:project_id.</p>

<p>``` coffeescript javascripts/backbone/models/bug.js.coffee
class Trackbone.Models.Bug extends Backbone.Model
  paramRoot: 'bug'</p>

<p>  defaults:</p>

<pre><code>name: null
</code></pre>

<p>class Trackbone.Collections.BugsCollection extends Backbone.Collection
  model: Trackbone.Models.Bug
  initialize: (model, args) -></p>

<pre><code>@url = -&gt;
  args.feature_url + "/bugs"
</code></pre>

<p>```</p>

<p><strong>Backbone Routers:</strong></p>

<p>Next we need to create the Projects router which will be the entry point into our single page app.</p>

<p>``` coffeescript javascripts/backbone/routers/projects_router.js.coffee
class Trackbone.Routers.ProjectsRouter extends Backbone.Router
  initialize: (options) -></p>

<pre><code>@projects = new Trackbone.Collections.ProjectsCollection()
@projects.reset options.projects
</code></pre>

<p>  routes:</p>

<pre><code>".*" : "index"
</code></pre>

<p>  index: -></p>

<pre><code>@view = new Trackbone.Views.Projects.IndexView(projects: @projects)
$("#list-projects").html(@view.render().el)

@newProjectView = new Trackbone.Views.Projects.NewView(collection: @projects)
$("#new-projects").html(@newProjectView.render().el)
</code></pre>

<p>```</p>

<p>Because we're not worrying about permalinks (yet! I've started looking into this, and hope to create a follow-up post), we only need one catch-all route. We then pass in the respective models to our views.</p>

<p><strong>Listing projects:</strong></p>

<p>``` html views/projects/index.html.erb</p>

<h1>Trackbone</h1>


<hr>


<div class="container">
  <div id="new-projects"></div>
  <div id="list-projects"></div>
</div>


<div class="container">
  <div id="new-features"></div>
  <div id="list-features"></div>
</div>


<div class="container">
  <div id="new-bugs"></div>
  <div id="list-bugs"></div>
</div>




<script type="text/javascript">
  $(function() {
    window.router = new Trackbone.Routers.ProjectsRouter(
      { projects: <%= @projects.to_json.html_safe -%> }
    );
    Backbone.history.start();
  });
</script>


<p>```</p>

<p>There is a container, new, and list div for each model. Backbone will load data from our Rest API, build HTML using the Views and Templates and inject that HTML into those DIV elements. Note that we are passing in projects from Rails to the router. This allows us to grab data from the server when the page is first requested and save an additional call on page load. Since this is a single page app, this is the only Rails view we need.</p>

<p>To display our Project data we need three templates: index to list projects, project for a specific item, and new to create a project.</p>

<p><code>html javascripts/backbone/templates/shared/item.jst.ejs
&lt;td&gt;&lt;a href="#" class="select"&gt;&lt;%= name %&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href="#" class="destroy"&gt;Destroy&lt;/a&gt;&lt;/td&gt;
</code></p>

<p>``` html javascripts/backbone/templates/projects/index.jst.ejs</p>

<h1>Listing projects</h1>




<table id="projects-table">
  <tr>
    <th>Name</th>
    <th></th>
  </tr>
</table>




<br/>


<p>```</p>

<p>``` html javascripts/backbone/templates/projects/new.jst.ejs</p>

<h1>New project</h1>


<p><form id="new-project" name="project">
  <div class="field"></p>

<pre><code>&lt;label for="name"&gt; name:&lt;/label&gt;
&lt;input type="text" name="name" id="name" value="&lt;%= name %&gt;" &gt;
</code></pre>

<p>  </div></p>

<p>  <div class="actions"></p>

<pre><code>&lt;input type="submit" value="Create Project" /&gt;
</code></pre>

<p>  </div></p>

<p></form>
```</p>

<p>These should be fairly self-explanatory. Each template will also need a Backbone View as well.</p>

<p>``` coffeescript javascripts/backbone/views/projects/index_view.js.coffee
Trackbone.Views.Projects ||= {}</p>

<p>class Trackbone.Views.Projects.IndexView extends Backbone.View
  template: JST["backbone/templates/projects/index"]</p>

<p>  initialize: () -></p>

<pre><code>@options.projects.bind('reset', @addAll)
@options.projects.bind('sync', @render)
</code></pre>

<p>  addAll: () =></p>

<pre><code>@options.projects.each(@addOne)
</code></pre>

<p>  addOne: (project) =></p>

<pre><code>view = new Trackbone.Views.Projects.ProjectView({model : project})
@$("tbody").append(view.render().el)
</code></pre>

<p>  render: =></p>

<pre><code>$(@el).html(@template(projects: @options.projects.toJSON()))
@addAll()

return this
</code></pre>

<p>```</p>

<p>This view receives the entire list of projects, renders the index view and appends a project view for each project.</p>

<p>``` coffeescript javascripts/backbone/views/projects/new_view.js.coffee
Trackbone.Views.Projects ||= {}</p>

<p>class Trackbone.Views.Projects.NewView extends Backbone.View
  template: JST["backbone/templates/projects/new"]</p>

<p>  events:</p>

<pre><code>"submit #new-project": "save"
</code></pre>

<p>  save: (e) -></p>

<pre><code>e.preventDefault()
e.stopPropagation()

name = $("#new-project #name").val()
if name
  $("#new-project #name").val('')
  @collection.create(name: name)
</code></pre>

<p>  render: -></p>

<pre><code>$(@el).html(@template())

return this
</code></pre>

<p>```</p>

<p>The new view simply providers a handler for creating a new project within the collection. The create method actually does three things: creates the model, POSTs the model to the server, and adds the model to the collection.</p>

<p>``` coffeescript javascripts/backbone/views/projects/project_view.js.coffee
Trackbone.Views.Projects ||= {}</p>

<p>class Trackbone.Views.Projects.ProjectView extends Backbone.View
  template: JST["backbone/templates/shared/item"]</p>

<p>  events:</p>

<pre><code>"click .select" : "select"
"click .destroy" : "destroy"
</code></pre>

<p>  tagName: "tr"
  className: "item"</p>

<p>  select: () -></p>

<pre><code>window.toggleSelected(@el)
@model.loadFeatures()
do (@model) -&gt;
  @model.features.fetch success: -&gt;
    featuresView = new Trackbone.Views.Features.IndexView(features: @model.features)
    $("#list-features").html(featuresView.render().el)

    # We should probably only render this once instead of each load
    newFeaturesView = new Trackbone.Views.Features.NewView(collection: @model.features)
    $("#new-features").html(newFeaturesView.render().el)

    $("#list-bugs").html('')
    $("#new-bugs").html('')
@model.features.fetch()
</code></pre>

<p>  destroy: () -></p>

<pre><code>@model.destroy()
this.remove()

return false
</code></pre>

<p>  render: -></p>

<pre><code>$(@el).html(@template(@model.toJSON() ))
return this
</code></pre>

<p>```</p>

<p>This view is really the heart of the app. Every time a Project is selected, we'll display the Features for that Project by calling fetch() and binding to success().</p>

<p>I'm not going to inline the templates and views for Features and Bugs since they are more or less identical, but feel free to browse through all the <a href="https://github.com/skalb/trackbone/tree/version1/app/assets/javascripts/backbone">client side code</a></p>

<p>Again, here's a working <a href="http://young-flower-9677.herokuapp.com/">demo</a>.</p>

<p>Please provide any feedback you have in the comments. Was this useful? Too long? Too much/too little code inline? I'm currently working on a couple more entires that will build on this one as I'm learning more about Backbone.js, so feedback is definitely useful.</p>
]]></content>
  </entry>
  
</feed>
